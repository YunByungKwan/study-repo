# 22장 클린 아키텍처

아키텍처들 간에는 세부적인 요소가 차이가 있지만, 목표는 모두 같다. 바로 관심사의 분리이다. 이들은 모두 소프트웨어를 계층으로 분리함으로서 관심사의 분리를 할 수 있었다. 아키텍처는 최소한 업무 규칙을 위한 계층 하나와, 사용자와 시스템 인터페이스를 위한 또 다른 계층 하나를 반드시 포함한다.
아키텍처는 다음과 같은 특징이 지니도록 만든다.

- `프레임워크 독립성`. 아키텍처는 다양한 기능의 라이브러리를 제공하는 소프트웨어, 즉 프레임워크의 존재 여부에 의존하지 않는다.
- `테스트 용이성`. 업무 규칙은 UI, 데이터베이스, 웹 서버, 또는 여타 외부 요소가 없이도 테스트할 수 있다.
- `UI 독립성`. 시스템의 나머지 부분을 변경하지 않고도 UI를 쉽게 변경할 수 있다.
- `데이터베이스 독립성`. 업무 규칙은 데이터베이스에 결합되지 않는다.
- `모든 외부 에이전시에 대한 독립성`. 실제로 업무 규칙은 외부 세계와의 인터페이스에 대해 전혀 알지 못한다. 

<br>

<img width="1201" alt="스크린샷 2021-04-18 00 41 43" src="https://user-images.githubusercontent.com/21329617/115118590-e21c6580-9fde-11eb-8b54-f0c67373f1b2.png">

<br>

### 의존성 규칙

바깥쪽 원은 메커니즘이고, 안쪽 원은 정책이다. 이러한 아키텍처가 동작하도록 하는 가장 중요한 규칙은 의존성 <i>Dependency rule</i>이다.

> 소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.

내부의 원에 속한 요소는 외부의 원에 속한 어떤 것도 알지 못한다. 특히 내부의 원에 속한 코드는 외부의 원에 선언된 어떤 것에 대해서도 그 이름을 언급해서는 절대 안 된다.

같은 이유로, 외부의 원에 선언된 데이터 형식도 내부의 원에서 절대로 사용해서는 안 된다. 특히 그 데이터 형식이 외부의 원에 있는 프레임워크가 생성한 것이라면 더더욱 사용해서는 안된다.
<br>

**엔티티**
엔티티는 전사적인 핵심 업무 규칙을 캡슐화한다. 메서드를 가지는 객체이거나 일련의 데이터 구조와 함수의 집합일 수도 있다. 운영 관점에서 특정 애플리케이션에 무언가 변경이 필요하더라도 엔티티 계층에는 절대로 영향을 주어서는 안 된다.
<br>

**유스케이스**
유스케이스 계층의 소프트웨어는 애플리케이션에 특화된 업무 규칙을 포함 한다. 또한 시스템의 모든 유스케이스를 캡슐화하고 구현한다. 유스케이스는 엔티티로 들어오고 나가는 데이터 흐름을 조정하며, 엔티티가 자신의 핵심 업무 규칙을 사용해서 유스케이스의 목적을 달성하도록 이끈다. 운영 관점에서 애플리케이션이 변경된다면 유스케이스가 영향 받는다.
<br>

**인터페이스 어댑터**
이 계층은 데이터를 엔티티와 유스케이스에게 가장 편리한 형식에서 영속성용으로 사용중인 임의의 프레임워크(데이터베이스)가 이용하기에 가장 편리한 형식으로 반환한다. 예를 들어 MVC 아키텍처를 모두 포함한다.
<br>

**프레임워크와 드라이버**
프레임워크와 드라이버 계층은 모든 세부사항이 위치하는 곳이다. 웹은 세부사항이다. 데이터베이스는 세부사항이다. 이러한 것들을 모두 외부에 위치시켜서 피해를 최소화한다.
<br>

**경계 횡단하기**
예를 들어 유스케이스에서 프레젠터를 호출해야 한다고 가정해보자. 이때 직접 호출하면 `의존성 규칙` 을 위배한다. 따라서 유스케이스가 내부원의 인터페이스를 호출하도록 하고, 외부원의 프레젠터가 그 인터페이스를 구현하도록 만든다.
<br>

**경계를 횡단하는 데이터는 어떤 모습인가?**
경계를 가로질러 데이터를 전달할 때, 데이터는 항상 내부의 원에서 사용하기에 가장 편리한 형태를 가져야만 한다. DTO 같은