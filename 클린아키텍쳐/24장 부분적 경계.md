# 24장 부분적 경계

> 아키텍처 경계를 완벽하게 만드는 데는 비용이 많이 든다.

### 마지막 단계를 건너뛰기

부분적 경계를 생성하는 방법 하나는 독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행한 후, 단일 컴포넌트에 그대로 모아만 두는 것이다. 쌍방향 인터페이스도 그 컴포넌트에 있고, 입출력 데이터 구조도 거기에 있으며, 모든 것이 완전히 준비되어 있다. 하지만 이 모두를 단일 컴포넌트로 컴파일해서 배포한다.
<br>

### 일차원 경계

완벽한 형태의 아키텍처 경계는 양방향으로 격리된 상태를 유지해야 하므로 쌍방향 Boundary 인터페이스를 사용한다. 양방향 격리 상태를 유지하려면 비용이 많이든다. 
다음은 추후 완벽한 형태의 경계로 확장할 수 있는 공간을 확보하고자 할 때 활용할 수 있는 더 간단한 구조다.  (Strategy 패턴)

<br>

<img width="1242" alt="스크린샷 2021-04-18 01 29 56" src="https://user-images.githubusercontent.com/21329617/115119884-9620ef00-9fe5-11eb-9913-404c416e8463.png">

<br>

Client를 Serviceimpl로 부터 격리시키는데 필요한 의존성 역전이 이미 적용되었기 때문에 미래에 필요할 아키텍처 경계를 위한 무대를 마련한다는 점은 명백하다. 또한 이 다이어그램의 위험천만한 점선 화살표에서 보듯이 이러한 분리는 매우 빠르게 붕괴될 수 있다는 점도 명백하다.
<br>

### 퍼사드

이보다 훨씬 더 단순한 경계는 의존성 역전까지도 희생한 퍼사드 <i>Facede</i> 패턴이다. Facede 클래스에는 모든 서비스 클래스를 메서드 형태로 정의하고, 서비스 호출이 발생하면 해당 서비스 클래스로 호출을 전달한다. 클라이언트는 이들 서비스 클래스에 직접 접근할 수 없다.

<br>

<img width="1243" alt="스크린샷 2021-04-18 01 33 09" src="https://user-images.githubusercontent.com/21329617/115119989-09c2fc00-9fe6-11eb-9ec8-89d942b37135.png">

<br>