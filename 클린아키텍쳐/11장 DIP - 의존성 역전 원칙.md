# 11장 DIP - 의존성 역전 원칙



의존성 역전 원칙 (DIP)에서 말하는, 유연성이 극대화된 시스템이란

- 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.



우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰 (volatile) 구체적인 요소다.

- 이 구체적인 요소는 우리가 열심히 개발중이라 자주 변경될 수 밖에 없는 모듈들이다.



### 안정된 추상화

> 추상 인터페이스에 변경이 생기면 이를 구체화한 구현체들도 수정해야한다.
>
> 반대로 구체적인 구현체애 변경이 생기더라도 인터페이스는 변경될 필요가 없을것이다.
>
> 즉, 인터페이스는 구현체보다 변동성이 낮다.

의존성 역전 원칙(DIP)에서 전달하려는 코딩 실천법의 요약은

1. **변동성이 큰 구체 클래스를 참조하지 말라.**
   -  대신 추상 인터페이스를 참조해라
   - 추상 팩토리를 사용하도록 강제하라
2. **변동성이 큰 구체 클래스로부터 파생하지 말라**
   - 정적 타입 언어에서 상속은 모든 관계 중에 가장 강력한 동시에 변경하기 어렵다.
   - 상속은 신중하게 사용해야한다.
3. **구체 함수를 오버라이드 하지 말라**
   - 오버라이드하면 의존성을 상속하게 된다.
   - 의존성을 제거하려면 추상함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현해야 한다.
4. 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라
   - DIP 원칙을 다른 방식으로 풀어쓴 것



### 팩토리

<img width="584" alt="스크린샷 2021-03-28 14 47 02" src="https://user-images.githubusercontent.com/21329617/112743692-7729d100-8fd4-11eb-8700-359091ab9ec6.png">

- Application은 Service 인터페이스를 통해 ConcreateImpl를 사용하고 인스턴스를 생성해야한다.
- ConcreateImpl에 대해 의존성을 만들지 않으면서 인스턴스를 생성하기 위해 ServiceFactory 인터페이스의 makeSve를 사용한다.
- ServiceFactory Impl에서 구현된 makeSvc는 ConcreateImpl 인스턴스를 생성하고 Service 타입으로 반환한다.



곡선은 구체적인 것들로 부터 추상적인 것들을 분리한다.

- 소스 코드 의존성은 추상적인 쪽으로 향한다.
- 소스 코드 의존성은 제어흐름과는 반대 방향으로 역전된다. (구체적인 것과 추상적인 것)
  → 의존성 역전 (Dependency Inversion)



### 구체 컴포넌트

구체 컴포넌트에 구체적인 의존성이 없어야 하지만, DIP 위배를 모두 없앨 수는 없다.

- 최소한 하나는 포함할 것이다. 메인(Main)



### 결론

 DIP는 아키텍처 다이어그램에서 가장 눈에 드러나는 원칙이다.

- 의존성은 아키텍처 경계를 기준으로 더 추상적인 엔티티가 있는 쪽으로만 향한다.
- 이 규칙을 의존성 규칙이라 부른다.



---

[Reference]

- Clean Architecture (로버트 C.마틴)