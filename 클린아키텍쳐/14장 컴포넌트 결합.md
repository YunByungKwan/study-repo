### 14장 컴포넌트 결합

> 지금부터 다룰 세 가지 원칙은 컴포넌트 사이의 관계를 설명한다.



#### ADP: 의존성 비순환 원칙

> 컴포넌트 의존성 그래프에 순환(cycle)이 있어서는 안 된다.

- `숙취 증후군`: 나에게 의존하고 있던 무언가를 누군가 수정해서 내 코드가 되던게 안되는 경우

  -> 많은 개발자가 동일한 소스 파일을 수정하는 환경에서 발생

  -> 해결책: 주 단위 빌드 / 의존성 비순환 원칙

  

<B>주 단위 빌드(Weekly Build)</B>

- 중간 규모의 프로젝트에서 흔히 사용

- 일주일 중 첫 4일은 각자 개발

- 금요일에 통합 -> 망함

  

<B>순환 의존성 제거하기</B>

- `주 단위 빌드`의 해결책은 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것

- 컴포넌트는 개별 개발자가 책임질 수 있는 작업 단위가 됨

- 담당 개발자는 맡은 컴포넌트에 릴리즈 번호를 부여하고 다른 팀에서는 릴리스 버전에 따라 사용 여부를 결정함

  -> 어떤 팀도 다른 팀에 의해 좌우되지 않음

- 이 방식이 성공하기 위해서는 <B>컴포넌트 사이 의존성 구조를 반드시 관리</B>해야 한다

  (의존성 순환이 있으면 절대 안됨)

- 컴포넌트의 구조는 비순환 방향 그래프(DAG)여야 함

![그림 14.1 전형적인 컴포넌트 다이어그램](https://uchanlee.dev/static/d6ca8fdc9c1a119dc7da195141d491d3/0a47e/image-14.1.png)

그림 14.1 전형적인 컴포넌트 다이어그램

- 컴포넌트를 조립하여 애플리케이션을 만드는 다소 전형적인 구조

- 구조가 <B>방향 그래프</B>임에 주목하자

- 어느 컴포넌트에서 시작하더라도 최초 컴포넌트로 다시 돌아갈 수 없다 (비순환 방향 그래프임)

- 시스템을 전체 릴리즈할 경우 릴리즈 절차는 상향식으로 진행됨

  (Entities -> Database -> Interactors -> Presenters -> View -> Controllers -> Authorizer -> Main)



<B>순환이 컴포넌트 의존성 그래프에 미치는 영향</B>

![그림 14.2 순환 의존성](https://uchanlee.dev/static/6005b83720c2dd84929d83b923528691/0a47e/image-14.2.png)

그림 14.2 순환 의존성

- Entities -> Authorizer 의존성이 생기면 순환이 발생

  (Entities, Authorizer, Interactors는 사실상 하나의 거대 컴포넌트가 됨)

- 순환이 생기면 컴포넌트로 분리하기도 상당히 어려워짐



<B>순환 끊기</B>

1. 의존성 역전 원칙을 적용 (Entities <- Authorizer)


![그림 14.3 Entities와 Authorizer 사이의 의존성을 역전시킨다.](https://uchanlee.dev/static/7f579cd6cb89c723fb56ee99dd4f20e5/0a47e/image-14.3.png)

그림 14.3 Entities와 Authorizer 사이의 의존성을 역전시킨다.



2. Entities와 Authorizer가 모두 의존하는 새로운 컴포넌트를 만든다

![그림 14.4 Entities와 Authorizer 모두 의존하는 새로운 컴포넌트](https://uchanlee.dev/static/cc4bf0149d4882dab49d48b7fb723da1/0a47e/image-14.4.png)

그림 14.4 Entities와 Authorizer 모두 의존하는 새로운 컴포넌트



<B>흐트러짐(Jitters)</B>

- 위의 두번째 방법이 시사하는 바는 요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다는 것
- 컴포넌트 사이 순환이 발생하는지 항상 관찰해야 한다



<B>하향식(top-down) 설계</B>

- 컴포넌트 구조는 하향식으로 설계될 수 없다
- 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니라 시스템 성장과 함께 진화한다



#### SDP: 안정된 의존성 규칙

> 안정성의 방향으로(더 안정된 쪽에) 의존하라.

- 변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대로 안 된다.
- 한번 의존하게 되면 변동성이 큰 컴포넌트도 결국 변경이 어려워진다
- 변경하기 쉬운 모듈을 설계했지만,  누군가가 의존성을 매달아 버리면 변경하기 어려워진다
- 안정된 의존성 원칙을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다



<B>안정성</B>

- 소프트웨어 컴포넌트를 변경하기 어렵게 만드는 확실한 방법 하나는 수많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것

![그림 14.5 X는 안정된 컴포넌트다.](https://uchanlee.dev/static/944a6939b6e513b116ce684a437dd176/0a47e/image-14.5.png)

그림 14.5 X는 안정된 컴포넌트다.

- X는 세 컴포넌트가 X에 의존하기 때문에 X를 변경하지 말아야 할 이유가 3가지나 된다 (X는 세 컴포넌트를 책임진다)
- 반대로 X는 어디에도 의존하지 않기 때문에 X가 변경되도록 만들 수 있는 외적인 영향이 전혀 없다 (X는 독립적이다)




![그림 14.6 Y는 상당히 불안정한 컴포넌트다.](https://uchanlee.dev/static/edce24d78ce38e44183288b4dad71ec0/0a47e/image-14.6.png)

그림 14.6 Y는 상당히 불안정한 컴포넌트다.

- 어떤 컴포넌트도 Y에 의존하지 않기 때문에 Y는 책임성이 없다
- Y는 세개의 컴포넌트에 의존하므로 변경이 발생할 수 있는 외부 요인이 3가지이다 (Y는 의존적이다)



<B>안정성 지표</B>

- 컴포넌트로 들어오고 나가는 의존성 개수로 안정성을 측정해 볼 수 있다
  - Fan-in: 컴포넌트 내부의 클래스에 의존하는  컴포넌트 외부의 클래수 개수
  - Fan-out: 컴포넌트 외부의 클래스에 의존하는 컴포넌트 내부의 클래스 개수
  - I(불안정성): Fan-out  / (Fan-in + Fan-out)


![그림 14.7 예제](https://uchanlee.dev/static/049b66c58785a06ca06233d29f8f50c0/0a47e/image-14.7.png)

그림 14.7 예제

- Cc컴포넌트의 Fan-in = 3, Fan-out = 1, I = 1/4



<B>모든 컴포넌트가 안정적이어야 하는 것은 아니다</B>

- 모든 컴포넌트가 안정적인 것은 바람직하지 않다
- 불안정한 컴포넌트와 안정된 컴포넌트가 함께 있는 것이 좋다


![그림 14.8 세 컴포넌트로 구성된 시스템의 이상적인 구성](https://uchanlee.dev/static/dc69bd12c60636285300481d41f78c93/0a47e/image-14.8.png)

그림 14.8 세 컴포넌트로 구성된 시스템의 이상적인 구성

- 관례적으로 불안정한 컴포넌트를 위에 둠
- 위로 향하는 화살표가 있으면 SDP를 위배하는 상태가 된다 (DIP로 해결하자)



<B>추상 컴포넌트</B>

- 오로지 인터페이스만을 사용하는 컴포넌트는 정적 타입 언어(java, c#)에서 흔한 방식
- 동적 타입 언어(Ruby, Python)는 추상 컴포넌트가 전혀 존재하지 않을 뿐만 아니라 추상 컴포넌트로 향하는 의존성이 전혀 없다



#### SAP: 안정된 추상화 원칙

> 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.



<B>고수준 정책을 어디에 위치시켜야 하는가?</B>

- 안정된 컴포넌트(I = 0): 고수준 아키텍처나 정책 결정과 관련된 소프트웨어

- 불안정한 컴포넌트(I = 1): 쉽고 빠르게 변경할 수 있는 소프트웨어

- 고수준 정책을 안정된 컴포넌트에 위치시키면 수정이 어려워 시스템 전체가 유연성을 잃는다

- 컴포넌트가 최고로 안정된 상태이면서 동시에 변경에 유연하게 만드는 방법?

  -> 추상 클래스



<B>안정된 추상화 원칙</B>

- 안정성과 추상화 정도 사이의 관계를 정의

- 안정된 컴포넌트는 추상 컴포넌트여야 하고, 안정성이 컴포넌트를 확장하는 일을 방해해서는 안된다고 말함

- 불안정한 컴포넌트는 반드시 구체 컴포넌트여야 한다

  (컴포넌트 내부 구체적인 코드를 쉽게 변경할 수 있어야하기 때문)

- 안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어야 함

- SAP + SDP => 컴포넌트에 대한 DIP

  -> 의존성은 추상화의 방향으로 향하게 된다



<B>추상화 정도 측정하기 ~ 주계열과의 거리</B>

- 책 참고 (p.132 - p.138)



<B>결론</B>

- 이 장에서 설명한 의존성 관리 지표는 설계의 의존성과 추상화 정도가 내가 '훌륭한' 패턴이라고 생각하는 수준에 얼마나 잘 부합하는지를 측정한다
- 지표가 절대적이진 않지만 유용하게 쓰길 바란다

