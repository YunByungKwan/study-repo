# 33장 사례연구 : 비디오 판매

### 제품

아키텍처를 적용해볼 사례로 소프트웨어 튜토리얼 비디오를 판매하는 소프트웨어 시스템의 초기 아키텍처를 결정짓는 첫 단계는 액터와 유스케이스를 식별하는 것이다.

### 유스케이스 분석

![다운로드](https://user-images.githubusercontent.com/21329617/117541560-62b70a80-b04f-11eb-985e-5528b6c0e769.png)

액터의 관점에서 책임을 정의할 수 있는 단일책임 원칙에 따르면 네 액터가 시스템이 변경되어야 할 네 가지 주요 근원이 된다. 시스템을 분할하여 특정 액터의 변경이 나머지 액터에게는 전혀 영향을 미치지 않게 만들고자 한다.
중앙 점선으로된 유스케이스는 추상 유스케이스인데, 이는 범용적인 정책을 담고 있으며 다른 유스케이스에서 이를 더 구체화 한다.

### 컴포넌트 아키텍처

![다운로드 (1)](https://user-images.githubusercontent.com/21329617/117541694-f7ba0380-b04f-11eb-8e7d-c464ba23ecd5.png)

추상 유스케이스로 특수한 컴포넌트인 Catalog View와 Catalog Presenter는 해당 컴포넌트 내부에 추상클래스로 코드화되며 이를 상속받는 컴포넌트는 추상클래스로부터 상속받은 뷰와 프레젠터 클래스를 포함한다.
여러개의 jar로 나누어야 할까? 
- 각 컴포넌트는 단일 jar에 해당할 수 있지만 경계를 구분해서 뷰, 프레젠터, 인터렉터, 컨트롤러, 유틸리티 각각을 하나의 jar로 구분할 수 있고 (5개의 jar 그룹)
- 또는 뷰와 프레젠터를 같은 jar에 두고 나머지를 개별로 둘 수도 있다.
- 이처럼 각 컴포넌트들이 독립적으로 컴파일 + 빌드 할 수 있는 환경으로 구성되게끔 열어두면 시스템이 변경되는 양상에 맞춰 배포 방식을 조절할 수 있다.

### 의존성 관리

위 그림에서 제어흐름은 오른쪽에서 왼쪽으로 이동한다. 컨트롤러 -> 뷰
사실 대다수의 화살표는 왼쪽에서 오른쪽으로 향하고, 이는 아키텍처가 의존성 규칙을 준수하기 때문임.
모든 의존성은 경계선을 한 방향으로만 가로지르는데, 항상 더 높은 수준의 정책을 포함하는 컴포넌트를 향한다.

### 결론

위 그림은 두 가지 서로 다른 차원의 분리 개념을 포함하고 있다. 
- 단일 책임 원칙에 기반한 액터의 분리
- 의존성 규칙

이런 방식으로 코드를 한번 구조화 하고 나면 시스템을 실제로 배포하는 방식은 다양하게 선택할 수 있게 된다.
