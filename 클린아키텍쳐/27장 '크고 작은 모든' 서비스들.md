### 27장 '크고 작은 모든' 서비스들

-----

>  서비스 지향 '아키텍처'와 마이크로서비스 '아키텍처'는 최근에 큰 인기를 끌고 있다. 그 이유는 다음과 같다.
>
> - 서비스를 사용하면 상호 결합이 철저하게 분리되는 것처럼 보인다.  나중에 보겠지만, 이는 일부만 맞는 말이다.
> - 서비스를 사용하면 개발과 배포 독립성을 지원하는 것처럼 보인다. 나중에 보겠지만, 이 역시도 일부만 맞는 말이다.

<br>

### 서비스 아키텍처?

-----

- 서비스를 사용한다는 것이 본질적으로 아키텍처에 해당하는 것인가? -> <u>이 개념은 명백히 사실이 아니다.</u>

- 시스템의 아키텍처는 <B>의존성 규칙을 준수</B>하며 <B>고수준의 정책을 저수준의 세부사항으로부터 분리하는 경계</B>에 의해 정의된다.

- 단순히 애플리케이션의 행위를 분리할 뿐인 서비스는 값비싼 함수 호출에 불과하다.

- 서비스 자체로는 아키텍처를 정의하지 않는다.

  (But, 기능을 프로세스나 플랫폼에 독립적이게 서비스를 생성하면 도움이 될 때가 많음)

- 결국 서비스는 프로세스나 플랫폼 경계를 가로지르는 함수 호출에 지나지 않는다.

<br>

### 서비스의 이점?

-----

#### 결합 분리의 오류

시스템을 서비스들로 분리함으로써 얻게 되는 이점은?

- ~~서비스 사이의 결합이 확실히 분리된다. 각 서비스는 서로 다른 프로세스, 심지어 다른 프로세서에서 실행되며 다른 서비스의 변수에 접근이 불가능하다~~

  ->  서비스를 분리하더라도 프로세서 내의 또는 네트워크 상의 공유 자원 때문에 결합될 가능성이 여전히 존재한다.

#### 개발 및 배포 독립성의 오류

서비스를 사용함에 따른 또 다른 이점은?

- ~~전담팀이 서비스를 소유하고 운영한다는 점이다. 전담팀이 각 서비스를 작성하고, 유지보수하며, 운영하는 책임을 질 수 있다. 이러한 개발 및 배포 독립성은 확장 가능한 것으로 간주된다.~~

  ->  이러한 믿음 역시 극히 일부이다.

  - 서비스는 확장 가능한 시스템을 구축하는 유일한 선택이 아니다.

    (모노리틱 시스템, 컴포넌트 기반 시스템으로도 구축 가능)

  - '결합 분리 오류'에 따르면 서비스라고 항상 독립적으로 개발, 배포, 운영할 수 있는 것은 아니다.

    <br>

### 야옹이 문제

-----

> 9장에서 예를 들었던 택시 통합 시스템을 다시 살펴 보자.

![img](https://blog.kakaocdn.net/dn/cSvjIy/btqB9W9PMwe/wk6Bm1q4xo8VdVlip9owM1/img.png)그림 1. 택시 통합서비스를 구현하기 위해 배치된 서비스들

- <B>TaxiUI 서비스</B> - 고객을 담당하며, 고객은 모바일 기기를 이용해서 택시를 호출함

- <B>TaxiFinder 서비스</B> - 여러  TaxiSupplier의 현황을 검토하여 사용자에게 적합한 택시 후보들을 선별함.  해당 사용자에 할당된 단기 데이터 레코드에 후보 택시들의 정보를 저장함.
- <B>TaxiSelector 서비스</B> - 사용자가 지정한 비용, 시간, 고급 여부 등의 조건을 기초로 후보 택시 중에서 적합한 택시를 선택함. 그리고 해당 택시를 TaxiDispatcher 서비스로 전달함
- <B>TaxiDispatcher 서비스</B> - 해당 택시에 배차 지시를 함.



여기서, <B>야옹이를 배달하는 서비스</B>를 추가한다면...?

- 모든 서비스가 변경되어야 한다. (서비스들이 모두 결합되어 있기 때문)

  -> 이게 바로 <u>횡단 관심사가 지닌 문제</u>이다.

<br>

### 객체가 구출하다

-----

> 컴포넌트 기반 아키텍처에서는 이 문제를 어떻게 해결했을까?

-> 다형적으로 확장할 수 있는 클래스 집합을 생성해 새로운 기능을 처리하도록 함 (경계를 주목)

![img](https://blog.kakaocdn.net/dn/mKJIe/btqCdgk3Ngi/5zjKeXV4dxo7csw7Jxzxnk/img.png)객체 지향 방식으로 횡단 관심사를 처리하기

- 의존성들이 의존성 규칙을 준수하고 있음

- 배차에 특화된 로직 부분은 Rides 컴포넌트로 추출되고, 야옹이에 대한 신규 기능은 Kittens 컴포넌트에 들어갔음 (이들은 기존 컴포넌트들에 있는 추상 기반 클래스를 <B>템플릿 메서드</B>나 <B>전략 패턴</B> 등을 통해 오버라이드)

- Rides와 Kittens의 기능들을 구현하는 클래스들은 UI의 제어하에 팩토리가 생성된다.

  -> 이 전략을 통해 야옹이 기능을 구현하려면 TaxiUI만 변경하면 된다. 대신 jar 파일 등으로 로드하면 됨.

  -> 야옹이 기능은 결합이 분리되며, 독립적으로 개발, 배포 가능해짐.

<br>

### 컴포넌트 기반 서비스

-----

>  서비스에도 이렇게 할 수 있을까? Yes!

- 서비스가 반드시 소규모 단일체여야 할 이유는 없다

- 서비스는 SOLID 원칙대로 설계할 수 있고 컴포넌트 구조도 갖출 수 있다

  -> <u>따라서 기존 컴포넌트 변경 없이 새로운 컴포넌트를 추가할 수 있다.</u>

- 자바의 경우, <B>서비스 = jar파일에 포함된 추상 클래스들의 집합</B> 이라고 생각

  새로운 기능 추가는 새로운 jar파일을 만든다 (기존 jar를 확장해서 만들어짐)

  -> 새로운 기능 배포는 서비스 재배포가 아닌 단순 jar파일 추가로 바뀜

  -> 새로운 기능을 추가하는 행위가 <u>개방 폐쇄 원칙</u>을 준수하게 됨

![img](https://blog.kakaocdn.net/dn/brZDck/btqCbgfwXeV/czHS2hZuDXRMnp6D9StqnK/img.png)

<br>

### 횡단 관심사

-----

- 아키텍처 경계는 서비스의 사이가 아니라, 서비스를 관통하며 컴포넌트 단위로 분할함.

- 모든 주요 시스템이 횡단 관심사를 처리하려면 서비스 내부는 의존성 규칙도 준수하는 컴포넌트 아키텍처로 설계해야 한다.