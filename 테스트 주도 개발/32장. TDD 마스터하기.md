## 32장. TDD 마스터하기

> 이 장에서는 TDD를 여러분 각자의 습관에 통합시켜 나가는 과정에서<br>
> 숙고해볼 수 있는 몇 가지 질문을 던지고자 한다.

### 단계가 얼마나 커야 하나?
- 사실 여기에는 두 가지 질문이 숨어 있다고 함
  - 각 테스트가 다뤄야 할 범위는 얼마나 넓은가?
  - 리팩토링을 하면서 얼마나 많은 중간 단계를 거쳐야 하는가?
- 우리는 규모가 작은 테스트와 큰 테스트를 모두 작성할 수 있어야 한다
- 시간이 지남에 따라 테스트 주도 개발자는 단계를 점점 작게 한다.
- 몇몇은 애플리케이션 수준의 테스트만 하기도 하고 몇몇은 프로그래머 수준의 테스트와 병행하기도 한다.
- 리팩토링 초기에는 아주 작은 단계로 작업할 준비가 되어 있어야 한다.  
- 자동화 리팩토링 툴은 리팩토링을 엄청나게 가속화시킨다.
- 단계가 횟수?

### 테스트할 필요가 없는 것은 무엇인가?
- 스스로 찾아야 하지만, 아래 목록을 시도해봐라.
  - 조건문
  - 반복문
  - 연산자
  - 다형성
- 당신이 작성하는 것들에 대해서만 테스트해라.
- 불신할 이유가 없다면 다른 사람의 코드를 테스트하지 마라.

### 좋은 테스트를 갖췄는지의 여부를 어떻게 알 수 있는가?
- 다음은 설계 문제가 있음을 알려주는 테스트의 속성들
  - 긴 셋업 코드
    - 단언문은 하나인데, 객체 생성 코드가 수백 줄 -> 문제 있다. 객체를 나눌 필요가 있음
  - 셋업 중복
    - 공통 셋업 코드를 넣을 곳이 없다? -> 서로 밀접하게 엉킨 객체들이 너무 많다는 뜻
  - 실행 시간이 오래 걸리는 테스트
    - 테스트가 실행이 오래 걸리면 실행을 잘 안하게 됨
    - 더 나쁜 건 애플리케이션의 작은 부분만 테스트하기 힘들다.
  - 깨지기 쉬운 테스트
    - 예상치 못하게 실패하는 테스트가 있다? -> 연결을 끊거나 두 부분을 합한다.
    - 왜냐면 한쪽이 어느 다른 한쪽에게 이상한 영향을 끼치고 있기 때문
    
### TDD로 프레임워크를 만들려면 어떻게 해야 하나?
- TDD: "오늘을 위해 설계하고 내일을 위해 코딩하라."처럼 보임
- 실제로 벌어지는 일
  - 첫 번째 기능을 구현한다. 이 첫 번째 기능은 단순하고 직관적으로 구현되고,<br>
    따라서 짧은 시간 안에 결함도 적은 상태로 완성된다.
  - 첫 번째 기능에 대한 변주가 되는 두 번째 기능을 구현한다. 두 기능<br>
    사이의 중복이 한 곳으로 모이고, 서로 다른 부분은 다른 곳(다른 메서드나 심지어 다른 클래스)으로 옮겨진다.
  - 앞의 두 기능에 대한 변주로 세 번째 기능을 구현한다. 공통의 로직은
    약간의 수정만을 통해 재활용 가능한 상태로 만들어질 수 있을 것이다.
    그리고 공통적이지 않은 로직들은 다른 메서드 혹은 클래스 등 명확하게
    로직이 있어야 할 곳에 있게 되는 경향이 있다.
    
- 개방-폐쇄 원칙이 잘 지켜진다.
- 테스트 주도 개발은 발생하는 변주 종류들을 잘 표현하는 프레임워크를 만들게 해 준다.
- 프레임워크를 만들 때 TDD로 하면 미리 설계한 것처럼 보이지만 빠르게 고치면서 완성한다는 것

### 피드백이 얼마나 필요한가?
- 삼각형의 각 변의 길이를 나타내는 세 개의 정수를 받아서 값을 반환하는 문제
  - 글쓴이는 이 문제에 대해 6개의 테스트를 작성했다.
  - 밥 바인더(Bob Binder)는 이 문제에 대해 65개의 테스트를 작성했다.
- 테스트를 얼마나 작성할지 고려할 때, `실패간 평균시간(MTBF, Mean Time Between Failures)`을 고려.
- TDD의 테스트에 대한 관점은 실용적이다.<br>
  -> <U>만약 어떤 구현에 대한 지식이 신뢰할 만 하다면 그에 대한 테스트는 작성하지 않을 것</U>
- 자신의 경험과 숙고를 통해, 얼마나 많은 테스트를 작성할지 결정해야 한다.

### 테스트를 지워야 할 때는 언제인가?
서로 겹치는 두 개의 테스트가 있는 경우? 아래 두 기준으로 결정한다.
- 자신감(지웠을 때 자신감이 떨어질 것 같으면 삭제ㄴㄴ)
- 커뮤니케이션(동일한 코드 부분을 실행하더라도 둘이 서로 다른 시나리오를 말한다면 남겨야 됨)

만약, 자신감, 커뮤니케이션 모두 이득이 별로 없는 중복 테스트 두개라면 <B>덜 유용한 것</B>을 삭제하라.

### 프로그래밍 언어나 환경이 TDD에 어떤 영향을 주는가?
어떻게 될까?<br>

### 거대한 시스템을 개발할 때에도 TDD를 할 수 있는가?
- 총 250,000줄의 제품 코드와 250,000줄의 테스트 코드 분량의 프로젝트를 해봤는데<br>
  총 4,000개의 테스트가 20분 이내에 실행됐다<br>
  즉, 애플리케이션의 크기와 무관하게 독립적으로 실행되므로 TDD를 할 수 있다
  
### 애플리케이션 수준의 테스트로도 개발을 주도할 수 있는가?
> 작은 규모의 테스트(단위테스트)로 개발을 주도하는 것의 문제는<br>
> 실제로 사용자가 원하지 않는데 그들이 원할 거라 생각하고 구현할 수도 있는 위험을<br>
> 끌고 간다는 점에 있다.<br>

- 사용자가 프로그래머의 도움을 받아 직접 테스트를 작성한다면?<br>
  여기에는 기술적 문제와 사회적 문제가 있다.
  - 기술적 문제: 아직 만들지 않은 기능에 대한 테스트를 어떻게 작성하고 실행할 것인가?
    - 우아하게 에러를 뱉어내는 해석기를 도입(?) 
  - 사회적 문제: 사용자에게 기존에 없던 새로운 책임을 부과함.<br>
    심지어 구현하기 전에 책임을 부과함;;
  - 또 다른 문제: 테스트와 피드백 사이의 길이(고객이 하면 빨간 막대만 볼수도)<br>
    -> <U>그러므로 프로그래머 수준의 TDD를 원할 거 같다</U>
    
### 프로젝트 중반에 TDD를 도입하려면 어떻게 해야 할까?
- 테스트를 염두에 두지 않고 만든 코드는 테스트하기가 그리 쉽지 않다
- 하면 안되는 일: 코드 전체를 위한 테스트를 한꺼번에 다 만들고,<br>
  코드 전체를 한번에 리팩토링 하는 것
- 우선 해야 할 일
  - 변경의 범위를 제한하자.
  - 테스트와 리팩토링 사이에 존재하는 교착상태(deadlock)를 풀어주자.<br>
    테스트가 아닌 다른 방법도 있다.
    - 아주 조심스럽게 작업(아조작)
    - 파트너와 함께 작업

### TDD는 누구를 위한 것인가?
- 어느 정도 작동하는 코드를 작성하고, 쳐다보지 않는다면 TDD는 당신의 것이 아니다.
- TDD는 더 나은 코드를 작성한다면 좀 더 성공할 것이라는,<br>
  매력적일 정도로 나이브하며 해커적인 가정에 근거한다.
- 적당한 수준의 엔지니어링만으로도 프로젝트는 성공할 수 있다.<br>
  하지만, 깨끗한 설계의 코드를 원한다면 TDD는 당신의 것이다.

### TDD는 초기 조건에 민감한가?
과연 그럴까?<br>

### TDD와 패턴의 관계는?
- 반복적으로 행동을 하다 보면, 익숙해져서 빨라지고 남은 시간에 새로운 생각을 할 수 있다.
- 패턴 주도 설계에 대한 구현 방법으로써의 TDD<br>
  A를 하기 위해 B패턴을 사용하기로 했어.<br>
  그래서 B패턴을 나타나도록 테스트를 작성하다 보면<br>
  결국에는 설계 아이디어가 틀린 것으로 판명난다.<br>
  <U>설계는 나중에 알아서 정해지도록 하고 시스템이 무슨 일을 할지를 생각하는 게 낫다.</U>
  
### 어째서 TDD가 잘 작동하는가?
- 제정신이 아닌듯
- 결국 하는 말은 TDD가 좋다, 시도해 봐라.
- TDD의 또 다른 효과는 설계 결정에 대한 피드백 고리를 단축시킨다.<br>
  설계를 결정짓는데 짧게 짧게 피드백을 반복하면서 결정 짓는 걸 도와준다.

### 이름을 테스트 주도 개발이라고 한 이유는?
`자동화되고 구체적이며 명확한 테스트`로<br>
`분석, 논리적 설계, 물리적 설계, 구현, 테스팅, 검토, 통합, 배포를 아우르는 복잡한 춤`을 주도하는 것<br>

### TDD와 익스트림 프로그래밍의 실천법 사이에 어떤 관련이 있는가?
다음은 XP의 나머지 부분이 TDD를 어떻게 향상시키는지,<br>
그리고 TDD가 XP의 나머지 부분을 어떻게 향상시키는지에 대한 간략한 요약이다.

- 짝 프로그래밍: TDD를 하면서 작성하게 되는 테스트는 짝 프로그래밍 과정에서 뛰어난 의사소통 수단이 된다.
- 활기차게 일하기: 힘들땐 쉬어라.
- 지속적인 통합: 좀 더 자주 통합할 수 있게 해준다.
- 단순 설계: 필요한 만큼만 코딩하고 중복을 제거하자.
- 리팩토링: 테스트가 있다면 리팩토링해도 자신감을 얻을 수 있다.
- 지속적인 전달

### 다락의 도전(참고)
다락이 엔지니어 사이에 나도는 오류가 있다고 함
- GUI에 대한 자동화 테스트는 만들 수 없다.
- 분산 객체에 대한 자동화 테스트는 만들 수 없다.
- 외부 도구가 생성한 코드나 서드파티 코드를 테스트할 필요는 없다.
- BNF에서부터 상용화 가능한 수준의 구현에 이르기까지, 언어 컴파일러나<br>
  인터프리터 등은 TDD로 만들어낼 수 없다.