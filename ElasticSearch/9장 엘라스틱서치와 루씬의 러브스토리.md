# Elastic Search - 9

D-Day: D +49
날짜: Dec 27, 2020
종료 여부: No
최종수정일: Dec 26, 2020 5:17 PM

# 09. 엘라스틱서치와 루씬

---

엘라스틱 서치는 내부적으로 루씬을 통한 검색 기능 수행.

루씬 라이브러리란?

## 9.1 클러스터 관점에서 구성요소 살펴보기

---

기본적으로 엘라스틱서치는 클러스터라는 단위로 데이터 제공.

최상위 개념인 클러스터부터 → 세그먼트까지 개념을 살펴보자.

### 9.1.1 클러스터

---

- 실제로 데이터를 가지고 있는 노드의 모음
- ES에서는 관련된 모든 노드를 논리적으로 확장해서 클러스터라 칭함
- 클러스터 내부의 데이터만 서로 공유가 가능

👼🏻 Cross Cluster Search

- 필요에 의해 다수의 클러스터를 한 번에 검색할 수 있게 하는 기능

### 9.1.2 노드

---

- 물리적으로 실행된 런타임 상태의 엘라스틱서치
- 클러스터를 운영하기 위해 물리 서버에 엘라스틱설치→ 실행된 엘라스틱 서치 인스턴스 == 노드
- 클러스터 구성원의 일부, 데이터를 물리적으로 가지고 있는 단일 서버

- 노드 내부에는 다수의 인덱스를 포함
    - 인덱스는 다수의 문서
- 모든 노드는 마스터 노드와 데이터 노드의 역할을 동시에 수행
    - 실운영시에는 역할에 따라 노드 물리적 분리가 좋음

- Master Node
    - 클러스터의 제어 담당
- Data Node
    - 데이터를 보유하고 CRUD, 검색, 집계 등 데이터 관련 작업 담당
- Ingest Node
    - 색인 전 전처리 작업을 담당
- Tribe Node
    - 여러 클러스터 제한적으로 연결, 동시 검색 (`Deprecated`)→  Cross Cluster Search
- Coordinating Node
    - 검색이나 집계 시 분산 처리만을 목적

### 9.1.3 인덱스

---

- 유사한 특성을 가지고 있는 문서를 모아둔 문서들의 컬렉션
- 클러스터 내부에서 유일한 인덱스 명을 가져야 함.
- 인덱스명은 모두 소문자

Index와 Type의 관계
→ 과거에는 여려 유형의 문서를 같은 인덱스에 저장하도록 타입을 사용했으나 사용 X

### 9.1.4 문서

---

- 검색 대상이 되는 실제 물리적인 데이터
- JSON 형식
- 실제로는 물리적인 샤드 형태로 나누어져 다수 노드로 분산 저장

### 9.1.5 샤드

---

- 데이터를 분산 저장하기 위한 방식
- 지속적으로 증가하는 콘텐츠를 수평적으로 분할
- 샤드를 통한 분산 처리로 인한 성능이나 처리량 향상

### 9.1.6 레플리카

---

- 샤드의 복제본
- 레플리카를 이용한 FailOver mechanism

![Elastic%20Search%20-%209%20c0e1e695a4a94c28bedd00ff8d693b1b/Untitled.png](Elastic%20Search%20-%209%20c0e1e695a4a94c28bedd00ff8d693b1b/Untitled.png)

### 9.1.7 세그먼트

---

- 루씬은 데이터가 색인되면 데이터는 최소한의 단위인 토큰으로 분리되고 특수한 형태의 자료구조로 저장하는데 → 세그먼트
- 읽기에 최적화된 자료구조로서 역색인이라는 특수한 형태로 변환되어 물리적 디스크에 저장

## 9.2 엘라스틱 서치 샤드 vs 루씬 인덱스

---

- 루씬 인덱스는 자신이 가지고 있는 세그먼트 내에서만 검색 가능
    - 샤드는 모든 샤드가 가지고 있는 세그먼트들을 논리적으로 통합하여 검색 가능

![Elastic%20Search%20-%209%20c0e1e695a4a94c28bedd00ff8d693b1b/KakaoTalk_20201226_155736282.jpg](Elastic%20Search%20-%209%20c0e1e695a4a94c28bedd00ff8d693b1b/KakaoTalk_20201226_155736282.jpg)

## 9.3 엘라스틱서치가 근실시간 검색을 제공하는 이유

---

### 9.3.1 색인 작업 시 세그먼트의 기본 동작 방식

---

- 하나의 세그먼트로 요청하는 것보다 다수의 세그먼트를 생성해 나눠처리하는것이 효율적
- 커밋 포인트를 활용한 세그먼트 검색(Index Searcher)
- 세그먼트 파일 병합 → 커다란 하나의 세그먼트
- 수정을 허용하지 않는 특성 때문에 세그먼트 생성

### 9.3.2 세그먼트 불변성

---

수정을 허용하지 않는 동작 방식을 불변성이라고 부름.

- 동시성 문제 회피 가능
- 시스템 캐시 적극적 활용 가능
- 높은 캐시 적중률 유지
- 리소스 절감

### 9.3.3 .세그먼트 불변성과 업데이트

---

- Update → 해당 데이터를 삭제 후 다시 추가
- 삭제 요청이 들어오면 데어티의 비트 배열을 찾아 삭제 여부 표시
- Merge가 일어나면 실질저긍로 삭-제

### 9.3.4 루씬을 위한 Flush, Commit, Merge

---

- 루씬은 버퍼가 있어서 효율적인 작업을 함
- 인메모리 버퍼를 순차적으로 쌓아 큐로 활용
    - 이러한 인메모리 버퍼 기반의 처리 과정을 Flush
- Merge → Commit 동반(연산 뿜뿜)

### 9.3.5 엘라스틱서치를 위한 Refresh, Optimize API

---

- 루씬에서 제공하는 거시기를 고가용성에 적합하도록 개선 및 확장해서 제공

**Refresh**

- Flush를 Refresh
- 모든 샤드에서 기본적으로 1초마다 한번

**Flush**

- Commit → Flush
- translog 샤드의 장애 복구를 위해 제공되는 파일
    - 내부에 존재하는 루씬 호출
- Commit 수행하고 장애복구를 위한 Translog를 정리하는 일련과정 통칭

**Optimize API**

- 인덱스 최적화

### 9.3.6 엘라스틱서치와 NRT

---

- 샤드는 장애 복구 기능을 가진 작은 루씬 기반의 단일 검색 서버

## 9.4 고가용성을 위한 Translog의 비밀

---

- 장애 복구를 위한 백업 데이터 및 데이터 유실 방지 저장소 Translog

### 9.4.1 Translog 동작 순서

---

- 샤드에 변경사항 생길 시
1. Translog 파일에 내역 기록
2. 루씬 인덱스로 데이터 전달
3. 세그먼트 생성

Flush 5초에 한번 → Translog 삭제

(Flush 물리적으로 기록되기에 영구적이라고 판단)

### 9.4.2 Translog 존재 이유

---

- 클러스터를 운영하는 중 데이터가 손실되지 않도록 보장
- 샤드 크래시

## 9.5 엘라스틱서치 샤드 최적화

---

- 최적화 고민하기

### 9.5.1 운영 중 샤드 개수 수정 못하는 이유

---

잘 계산해라

- 각 샤드는 내부에 독립적인 루씬 라이브러리.
- StandAlone

- 프라이머리 샤드
- 레플리카 샤드

### 9.5.2 레플리카 샤드의 복제본 수는 얼마가 적당?

---

- 복제본은 운영 중에도 변경 가능.
- 모니터링하고 탄력적으로 조절해라

### 9.5.3 클러스터에서 운영 가능한 최대 샤드 수는?

---

- 1024개

- 샤드 수 증가 → 마스터 노드의 메모리 사용량 증가
- 샤드가 많으면 읽기 성능은 높아짐
- 복구 시에는 샤드 크기가 클수록 복구 작업에 부정적

5~8

### 9.5.4 하나의 인덱스에 생성 가능한 최대 문서 수

---

- 대략 20억개
- 개별 인덱스가 가질 수 있는 최대 문서 수는 2조개