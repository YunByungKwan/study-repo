# 12.안정적인 클러스터 운영

D-Day: D +83
날짜: Jan 30, 2021
종료 여부: No
최종수정일: Jan 30, 2021 3:14 PM

운영환경과 개발환경은 차이가 있음.

운영 환경이라고 판단되면 부트스트랩이라는 과정을 통해 설정이나 문제점을 알려준다.

## 12.1 노드 부트스트랩 과정의 이해

---

**필요한 이유**

- 단순히 경고 메시지를 로그에 출력하는 방식을 사용했으나, 수동적인 경고를 통해 운영자들이 심각성을 인지하지 못하고 넘어가기 부지기수
- 운영 시 발생되는 문제점을 미연에 방지하기 위해 좀 더 강력한 검사를 실시하고 이를 부트스트랩 체크라고 한다.
    - 이전의 수동적인 환경보다 강제로 종료하여 실행되도록 강제함

**개발모드**

- IP 주소가 루프백(localhost)으로 설정된 경우 개발 모드로 판단.
- 또는 노드가 한개일 경우에도 개발모드로 생각.

**운영모드**

- 실제 IP를 할당받고 운영 시 운영모드
- 1대만 운영하더라도 JVM 옵션을 통해 강제할 수 있음.

**체크과정**

1. 힙 크기 체크
    - 기본 힙 크기와 최대 힙 크기 값을 같게 설정해야 힙 크기 조정이 일어나서 일시 정지할 위험성을 없앨 수 있음.
2. 파일 디스크립터 체크
    - 리눅스는 모든 것을 파일로 처리하기에 파일 디스크립터가 충분한지 검사
3. 메모리 락 체크
    - 힙 구성하는 메모리 페이지 조각 중 단 하나라도 스왑아웃되있으면 스왑인 해야해서 부담을 주기에 스와핑 대상이 되지 않도록 메모리 락 여부 검사
4. 최대 스레드 수 체크
    - Thread Pool Executor가 여유롭게 스레드를 생성할 수 있도록 최소 4096개 생성하도록 세팅
5. 최대 가상 메모리 크기 체크
    - mmap을 이용하여 메모리 매핑을 수행하기에 리눅스가 생성하는 가상 메모리 크기 체크
6. 최대 파일 크기 체크
    - 세그먼트나 트랜스로그 팡리은 수십 GB 이상으로 커질수도 있기에 최대파일 크기가 무제한이어야 함
7. mmap 카운트 체크
    - 리눅스가 생성한 애플리케이션이 가질 수 있는 최대 mmap 카운트 검사
8. 클라이언트 JVM 체크
    - JVM이 Servler JVM으로 실행했는지 검사
9. Serial Collector 사용 여부 체크
    - Serial GC를 사용하지 않도록 사용 여부 검사
10. 시스템 콜 필터 체크
    - 유저 모드에서 커널 모드를 접근하는 시스템 콜을 제한하기 위한 콜 필터가 사용되고 있는지 검사
11. OnError, OnOutOfMemoryError 체크
    - 시스템 콜 필터를 사용할 경우 OnError 옵션이나 OnOutOfMemory 옵션 설정 여부 검사
12. Early-access 체크
    - JDK 공식 릴리즈 버젼인지 여부 검사
13. G1GC 체크
    - CMS 방식이 아닌 G1GC 사용여부 검사 *8버전부터는 G1GC 사용 ⇒ 8u40이후 버전 검사)
14. All Permission 체크
    - SecurityManager 를 통해 필요한 접근 권한을 받기에 적용 여부 검사

## 12.2 마스터 노드와 데이터 노드 분리하기

---

노드의 종류 및 운영방법

```bash
node.master // 마스터 기능 활성화 

node.data // 데이터 기능 활성화

node.ingest // Ingest 기능 활성화

search.remote.connect // 외부 클러스터 접속 가능 여부
```

**노드종류** 

- Single Node
    - 기본적인 Node 모드
    - 3대 이하의 클러스터 구축 시 활용
- Master Node
    - node.master 속성만 true, 나머지 false 명시할 경우 Master Node
    - 인덱스의 생성,변경 및 삭제 담당
    - 전체를 관장하는 마스터 역할 수행
    - 클러스터 내부에는 다수의 마스터가 필요하고 장애 발생시 후보 마스터가 역할을 위임받음
- Data Node
    - 데이터 보관 및 CRUD, 검색 집계 등 데이터 관련 작업을 담당하는 모드
    - node.data 속성만 true, 나머지 false 명시할 경우 Data Node
    - SSD나 고성능 CPU,메모리를 갖춘 서버 활용하기
- Ingest Node
    - 데이터를 색인 시 전처리를 담당하는 모드
    - node.ingest속성만 true, 나머지 false 명시할 경우 Ingest Node
    - 색인 시 크롤러를 개발해 색인 작업을 수행 → 간단한 전처리가 필요 시 활용
- Coordination Node
    - 모든 노드는 기본적으로 Coordination 노드
    - 클러스터를 안정적으로 운영하기 위해 사용자의 요청은 전용 Coordination 노드에서만 처리되도록 구성하기

**마스터 노드와 데이터 노드를 분리해야 하는 이유**

- 데이터를 샤드 단위로 분산 저장하는 방식으로 스케일 확장 = 샤드의 개수도 비례해서 늘어남
- 데이터가 커지면 싱글노드 사용 X
- 하나의 노드가 마스터+데이터면 하나에서 발생한 장애가 클러스터 전체의 장애로 번져나감
- 마스터 노드가 정상적으로 동작하지 않아도 프로세스가 살아있는 딜레마가 있음
- 통계기능 등 대량의 데이터를 처리해야하는 상황은 전용 Coordination 노드로만 용청받기

**클러스터 Split Brain 문제 방지**

일정 규모 이상의 클러스터에서는 반드시 마스터 노드를 물리적으로 분리하는 것이 좋음.

**Split Brain이란?**

- 후보 노드가 투표가 시작되기 직전에 네트워크 문제로 노드간 연결이 순간적으로 끊어지면 클러스터 안에 하나 이상의 마스터가 만들어지는 사고가 발생할 수 있음.
    - 뇌가 쪼개진다는 뜻

## 12.3 클러스터 관리 API

---

관리용 API 알아보기

**런타임에 환경설정 변경(_cluster/settings API)**

- 엘라스틱 환경설정을 동적으로 변경 가능.
- 인스턴스가 재시작되더라도 영구히 적용.
- elasticsearch.yml보다 우선순위가 높음.

**대기 중인 클러스터 변경 명령 조회(*cluster/pending*tasks API)**

- 대기 중인 클러스터 변경과 관련된 Task 목록을 실시간으로 모니터링 할 수 있음.
- 큐에 쌓인 Task 엿보기 가능.
- 병목 발생현상에 대해 파악하는데 유용

**사용률이 높은 스레드 조회(_nodes/*hot_*threads API)**

- 노드별로 사용률이 높은 스레드 정보를 확인할 수 있음.

**노드간 샤드 이동(_cluster/reroute API)**

- 특정 노드의 샤드를 원하는 노드로 이동시킬 수 있음.
- 물리적인 데이터가 네트워크를 통해 전송되기 때문에 리소스를 많이 소모함
    - 새벽이나 주말에 몰래하기

**실행 중인 태스크 조회(_tasks API)**

- 현재 클러스터에서 실행 중인 모든 태스크 정보를 검색할 수 있다.

**관리 API 호출 통계(_nodes/usage API)**

- 관리용 API를 호출한 현황을 조회할 수 있음.

관리용 API 호출하는것도 클러스터의 리소스를 사용하기에 적당히 훔쳐볼 것.

## 12.4 안정적인 클러스터 운영을 위한 주요 체크포인트

---

성능 모니터링 툴로 개바랗면 좋을 만한 대표적인 지표 알아보기.

**클러스터 상태 측정**

Cluster Health API를 활용하여 모니터링 하기

**검색 성능 측정**

검색 성능 측정 지표를 통해 인덱스별 통계나 노드별 통계 지표를 통해 모니터링

**색인 성능 측정**

색인할 문서의 크기가 매우 크다면 색인하는 과정을 모니터링 하고 분석하는데

리소스가 많이 먹으니 모니터링을 통해 측정하기

**HTTP 성능 측정**

외부와 연동하기 위해 HTTP를 사용하기 때문에 이를 활용하여 모니터링 하기

**GC 성능 측정**

GC 작업을 항상 모니터링 하기 → 자바 기반의 애플리케이션이기 때문에

**운영체제 성능 측정**

운영체제 수준의 성능 지표 및 다른 전문적인 툴을 이용해 수집하여 모니터링 하기

**스레드풀 상태 측정**

**캐시 상태 측정**

사용자가 직접 생성하는 fielddata 캐시가 있기에 캐시 상태도 측정하기